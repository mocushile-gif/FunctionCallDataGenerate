{
    "{'contract_name': 'Admin', 'contract_address': '0x097bafa4e0b48eef'}": {
        "error": "",
        "response": {
            "status": 0,
            "msg": "success",
            "id": 21,
            "contract_name": "Admin",
            "contract_address": "0x097bafa4e0b48eef",
            "contract_code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Debug from 0x097bafa4e0b48eef\nimport Clock from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\npub contract Admin {\n\n\t//store the proxy for the admin\n\tpub let AdminProxyPublicPath: PublicPath\n\tpub let AdminProxyStoragePath: StoragePath\n\n\n\t/// ===================================================================================\n\t// Admin things\n\t/// ===================================================================================\n\n\t//Admin client to use for capability receiver pattern\n\tpub fun createAdminProxyClient() : @AdminProxy {\n\t\treturn <- create AdminProxy()\n\t}\n\n\t//interface to use for capability receiver pattern\n\tpub resource interface AdminProxyClient {\n\t\tpub fun addCapability(_ cap: Capability<&FIND.Network>)\n\t}\n\n\n\t//admin proxy with capability receiver \n\tpub resource AdminProxy: AdminProxyClient {\n\n\t\taccess(self) var capability: Capability<&FIND.Network>?\n\n\t\tpub fun addCapability(_ cap: Capability<&FIND.Network>) {\n\t\t\tpre {\n\t\t\t\tcap.check() : \"Invalid server capablity\"\n\t\t\t\tself.capability == nil : \"Server already set\"\n\t\t\t}\n\t\t\tself.capability = cap\n\t\t}\n\n\t\t/// Set the wallet used for the network\n\t\t/// @param _ The FT receiver to send the money to\n\t\tpub fun setWallet(_ wallet: Capability<&{FungibleToken.Receiver}>) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.setWallet(wallet)\n\t\t}\n\n\t\t/// Enable or disable public registration \n\t\tpub fun setPublicEnabled(_ enabled: Bool) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.setPublicEnabled(enabled)\n\t\t}\n\n\t\tpub fun setAddonPrice(name: String, price: UFix64) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.setAddonPrice(name: name, price: price)\n\t\t}\n\n\t\tpub fun setPrice(default: UFix64, additional : {Int: UFix64}) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.setPrice(default: default, additionalPrices: additional)\n\t\t}\n\n\t\tpub fun register(name: String, profile: Capability<&{Profile.Public}>, leases: Capability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>){\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t\tFIND.validateFindName(name) : \"A FIND name has to be lower-cased alphanumeric or dashes and between 3 and 16 characters\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.internal_register(name:name, profile: profile, leases: leases)\n\t\t}\n\n\t\tpub fun mintCharity(metadata : {String: String}, recipient: Capability<&{NonFungibleToken.CollectionPublic}>){\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tCharityNFT.mintCharity(metadata: metadata, recipient: recipient)\n\t\t}\n\n\n\n\n\n\t\tpub fun advanceClock(_ time: UFix64) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\t\t\tDebug.enable(true)\n\t\t\tClock.enable()\n\t\t\tClock.tick(time)\n\t\t}\n\n\n\t\tpub fun debug(_ value: Bool) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\t\t\tDebug.enable(value)\n\t\t}\n\n\t\tinit() {\n\t\t\tself.capability = nil\n\t\t}\n\n\t}\n\n\tinit() {\n\n\t\tself.AdminProxyPublicPath= /public/findAdminProxy\n\t\tself.AdminProxyStoragePath=/storage/findAdminProxy\n\t}\n\n}\n",
            "contract_type": "transaction",
            "contract_category": "nft"
        }
    },
    "{'contract_address': '0x097bafa4e0b48eef', 'contract_name': 'Admin'}": {
        "error": "",
        "response": {
            "status": 0,
            "msg": "success",
            "id": 21,
            "contract_name": "Admin",
            "contract_address": "0x097bafa4e0b48eef",
            "contract_code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Debug from 0x097bafa4e0b48eef\nimport Clock from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\npub contract Admin {\n\n\t//store the proxy for the admin\n\tpub let AdminProxyPublicPath: PublicPath\n\tpub let AdminProxyStoragePath: StoragePath\n\n\n\t/// ===================================================================================\n\t// Admin things\n\t/// ===================================================================================\n\n\t//Admin client to use for capability receiver pattern\n\tpub fun createAdminProxyClient() : @AdminProxy {\n\t\treturn <- create AdminProxy()\n\t}\n\n\t//interface to use for capability receiver pattern\n\tpub resource interface AdminProxyClient {\n\t\tpub fun addCapability(_ cap: Capability<&FIND.Network>)\n\t}\n\n\n\t//admin proxy with capability receiver \n\tpub resource AdminProxy: AdminProxyClient {\n\n\t\taccess(self) var capability: Capability<&FIND.Network>?\n\n\t\tpub fun addCapability(_ cap: Capability<&FIND.Network>) {\n\t\t\tpre {\n\t\t\t\tcap.check() : \"Invalid server capablity\"\n\t\t\t\tself.capability == nil : \"Server already set\"\n\t\t\t}\n\t\t\tself.capability = cap\n\t\t}\n\n\t\t/// Set the wallet used for the network\n\t\t/// @param _ The FT receiver to send the money to\n\t\tpub fun setWallet(_ wallet: Capability<&{FungibleToken.Receiver}>) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.setWallet(wallet)\n\t\t}\n\n\t\t/// Enable or disable public registration \n\t\tpub fun setPublicEnabled(_ enabled: Bool) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.setPublicEnabled(enabled)\n\t\t}\n\n\t\tpub fun setAddonPrice(name: String, price: UFix64) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.setAddonPrice(name: name, price: price)\n\t\t}\n\n\t\tpub fun setPrice(default: UFix64, additional : {Int: UFix64}) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.setPrice(default: default, additionalPrices: additional)\n\t\t}\n\n\t\tpub fun register(name: String, profile: Capability<&{Profile.Public}>, leases: Capability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>){\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t\tFIND.validateFindName(name) : \"A FIND name has to be lower-cased alphanumeric or dashes and between 3 and 16 characters\"\n\t\t\t}\n\n\t\t\tself.capability!.borrow()!.internal_register(name:name, profile: profile, leases: leases)\n\t\t}\n\n\t\tpub fun mintCharity(metadata : {String: String}, recipient: Capability<&{NonFungibleToken.CollectionPublic}>){\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\n\t\t\tCharityNFT.mintCharity(metadata: metadata, recipient: recipient)\n\t\t}\n\n\n\n\n\n\t\tpub fun advanceClock(_ time: UFix64) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\t\t\tDebug.enable(true)\n\t\t\tClock.enable()\n\t\t\tClock.tick(time)\n\t\t}\n\n\n\t\tpub fun debug(_ value: Bool) {\n\t\t\tpre {\n\t\t\t\tself.capability != nil: \"Cannot create FIND, capability is not set\"\n\t\t\t}\n\t\t\tDebug.enable(value)\n\t\t}\n\n\t\tinit() {\n\t\t\tself.capability = nil\n\t\t}\n\n\t}\n\n\tinit() {\n\n\t\tself.AdminProxyPublicPath= /public/findAdminProxy\n\t\tself.AdminProxyStoragePath=/storage/findAdminProxy\n\t}\n\n}\n",
            "contract_type": "transaction",
            "contract_category": "nft"
        }
    },
    "{'contract_name': 'CharityNFT', 'contract_address': '0x097bafa4e0b48eef'}": {
        "error": "",
        "response": {
            "status": 0,
            "msg": "success",
            "id": 22,
            "contract_name": "CharityNFT",
            "contract_address": "0x097bafa4e0b48eef",
            "contract_code": "\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract CharityNFT: NonFungibleToken {\n\n\tpub var totalSupply: UInt64\n\n\tpub let CollectionStoragePath: StoragePath\n\tpub let CollectionPublicPath: PublicPath\n\n\tpub event ContractInitialized()\n\tpub event Withdraw(id: UInt64, from: Address?)\n\tpub event Deposit(id: UInt64, to: Address?)\n\tpub event Minted(id: UInt64, metadata: {String:String}, to:Address)\n\n\tpub resource NFT: NonFungibleToken.INFT, Public {\n\t\tpub let id: UInt64\n\n\t\taccess(self) let metadata: {String: String}\n\n\t\tinit(initID: UInt64, metadata: {String : String}) {\n\t\t\tself.id = initID\n\t\t\tself.metadata = metadata\n\t\t}\n\n\t\tpub fun getMetadata() : { String : String} {\n\t\t\treturn self.metadata\n\t\t}\n\t}\n\n\t//The public interface can show metadata and the content for the Art piece\n\tpub resource interface Public {\n\t\tpub let id: UInt64\n\t\tpub fun getMetadata() : {String : String}\n\t}\n\n\t//Standard NFT collectionPublic interface that can also borrowArt as the correct type\n\tpub resource interface CollectionPublic {\n\n\t\tpub fun deposit(token: @NonFungibleToken.NFT)\n\t\tpub fun getIDs(): [UInt64]\n\t\tpub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n\t\tpub fun borrowCharity(id: UInt64): &{Public}?\n\t}\n\n\tpub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, CollectionPublic {\n\t\t// dictionary of NFT conforming tokens\n\t\t// NFT is a resource type with an `UInt64` ID field\n\t\tpub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n\t\tinit () {\n\t\t\tself.ownedNFTs <- {}\n\t\t}\n\n\t\t// withdraw removes an NFT from the collection and moves it to the caller\n\t\tpub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\t\t\tlet token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n\t\t\temit Withdraw(id: token.id, from: self.owner?.address)\n\n\t\t\treturn <-token\n\t\t}\n\n\t\t// deposit takes a NFT and adds it to the collections dictionary\n\t\t// and adds the ID to the id array\n\t\tpub fun deposit(token: @NonFungibleToken.NFT) {\n\t\t\tlet token <- token as! @CharityNFT.NFT\n\n\t\t\tlet id: UInt64 = token.id\n\n\t\t\t// add the new token to the dictionary which removes the old one\n\t\t\tlet oldToken <- self.ownedNFTs[id] <- token\n\n\t\t\temit Deposit(id: id, to: self.owner?.address)\n\n\t\t\tdestroy oldToken\n\t\t}\n\n\t\t// getIDs returns an array of the IDs that are in the collection\n\t\tpub fun getIDs(): [UInt64] {\n\t\t\treturn self.ownedNFTs.keys\n\t\t}\n\n\t\t// borrowNFT gets a reference to an NFT in the collection\n\t\t// so that the caller can read its metadata and call its methods\n\t\tpub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n\t\t\treturn (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n\t\t}\n\n\t\t//borrow charity\n\t\tpub fun borrowCharity(id: UInt64): &{CharityNFT.Public}? {\n\t\t\tif self.ownedNFTs[id] != nil {\n\t\t\t\tlet ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n\t\t\t\treturn ref as! &NFT\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tdestroy() {\n\t\t\tdestroy self.ownedNFTs\n\t\t}\n\t}\n\n\t// public function that anyone can call to create a new empty collection\n\tpub fun createEmptyCollection(): @NonFungibleToken.Collection {\n\t\treturn <- create Collection()\n\t}\n\n\n\t// mintNFT mints a new NFT with a new ID\n\t// and deposit it in the recipients collection using their collection reference\n\taccess(account) fun mintCharity(metadata: {String:String}, recipient: Capability<&{NonFungibleToken.CollectionPublic}>) {\n\n\t\t// create a new NFT\n\t\tvar newNFT <- create NFT(initID: CharityNFT.totalSupply, metadata:metadata)\n\n\t\t// deposit it in the recipient's account using their reference\n\t\trecipient.borrow()!.deposit(token: <-newNFT)\n\t\temit Minted(id: CharityNFT.totalSupply, metadata:metadata, to: recipient.address)\n\n\t\tCharityNFT.totalSupply = CharityNFT.totalSupply + 1 \n\t}\n\n\tinit() {\n\t\t// Initialize the total supply\n\t\tself.totalSupply = 0\n\n\t\temit ContractInitialized()\n\t\tself.CollectionPublicPath=/public/findCharityCollection\n\t\tself.CollectionStoragePath=/storage/findCharityCollection\n\t}\n}\n\n",
            "contract_type": "contract",
            "contract_category": "nft"
        }
    },
    "{'contract_address': '0x097bafa4e0b48eef', 'contract_name': 'CharityNFT'}": {
        "error": "",
        "response": {
            "status": 0,
            "msg": "success",
            "id": 22,
            "contract_name": "CharityNFT",
            "contract_address": "0x097bafa4e0b48eef",
            "contract_code": "\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract CharityNFT: NonFungibleToken {\n\n\tpub var totalSupply: UInt64\n\n\tpub let CollectionStoragePath: StoragePath\n\tpub let CollectionPublicPath: PublicPath\n\n\tpub event ContractInitialized()\n\tpub event Withdraw(id: UInt64, from: Address?)\n\tpub event Deposit(id: UInt64, to: Address?)\n\tpub event Minted(id: UInt64, metadata: {String:String}, to:Address)\n\n\tpub resource NFT: NonFungibleToken.INFT, Public {\n\t\tpub let id: UInt64\n\n\t\taccess(self) let metadata: {String: String}\n\n\t\tinit(initID: UInt64, metadata: {String : String}) {\n\t\t\tself.id = initID\n\t\t\tself.metadata = metadata\n\t\t}\n\n\t\tpub fun getMetadata() : { String : String} {\n\t\t\treturn self.metadata\n\t\t}\n\t}\n\n\t//The public interface can show metadata and the content for the Art piece\n\tpub resource interface Public {\n\t\tpub let id: UInt64\n\t\tpub fun getMetadata() : {String : String}\n\t}\n\n\t//Standard NFT collectionPublic interface that can also borrowArt as the correct type\n\tpub resource interface CollectionPublic {\n\n\t\tpub fun deposit(token: @NonFungibleToken.NFT)\n\t\tpub fun getIDs(): [UInt64]\n\t\tpub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n\t\tpub fun borrowCharity(id: UInt64): &{Public}?\n\t}\n\n\tpub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, CollectionPublic {\n\t\t// dictionary of NFT conforming tokens\n\t\t// NFT is a resource type with an `UInt64` ID field\n\t\tpub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n\t\tinit () {\n\t\t\tself.ownedNFTs <- {}\n\t\t}\n\n\t\t// withdraw removes an NFT from the collection and moves it to the caller\n\t\tpub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\t\t\tlet token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n\t\t\temit Withdraw(id: token.id, from: self.owner?.address)\n\n\t\t\treturn <-token\n\t\t}\n\n\t\t// deposit takes a NFT and adds it to the collections dictionary\n\t\t// and adds the ID to the id array\n\t\tpub fun deposit(token: @NonFungibleToken.NFT) {\n\t\t\tlet token <- token as! @CharityNFT.NFT\n\n\t\t\tlet id: UInt64 = token.id\n\n\t\t\t// add the new token to the dictionary which removes the old one\n\t\t\tlet oldToken <- self.ownedNFTs[id] <- token\n\n\t\t\temit Deposit(id: id, to: self.owner?.address)\n\n\t\t\tdestroy oldToken\n\t\t}\n\n\t\t// getIDs returns an array of the IDs that are in the collection\n\t\tpub fun getIDs(): [UInt64] {\n\t\t\treturn self.ownedNFTs.keys\n\t\t}\n\n\t\t// borrowNFT gets a reference to an NFT in the collection\n\t\t// so that the caller can read its metadata and call its methods\n\t\tpub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n\t\t\treturn (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n\t\t}\n\n\t\t//borrow charity\n\t\tpub fun borrowCharity(id: UInt64): &{CharityNFT.Public}? {\n\t\t\tif self.ownedNFTs[id] != nil {\n\t\t\t\tlet ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n\t\t\t\treturn ref as! &NFT\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tdestroy() {\n\t\t\tdestroy self.ownedNFTs\n\t\t}\n\t}\n\n\t// public function that anyone can call to create a new empty collection\n\tpub fun createEmptyCollection(): @NonFungibleToken.Collection {\n\t\treturn <- create Collection()\n\t}\n\n\n\t// mintNFT mints a new NFT with a new ID\n\t// and deposit it in the recipients collection using their collection reference\n\taccess(account) fun mintCharity(metadata: {String:String}, recipient: Capability<&{NonFungibleToken.CollectionPublic}>) {\n\n\t\t// create a new NFT\n\t\tvar newNFT <- create NFT(initID: CharityNFT.totalSupply, metadata:metadata)\n\n\t\t// deposit it in the recipient's account using their reference\n\t\trecipient.borrow()!.deposit(token: <-newNFT)\n\t\temit Minted(id: CharityNFT.totalSupply, metadata:metadata, to: recipient.address)\n\n\t\tCharityNFT.totalSupply = CharityNFT.totalSupply + 1 \n\t}\n\n\tinit() {\n\t\t// Initialize the total supply\n\t\tself.totalSupply = 0\n\n\t\temit ContractInitialized()\n\t\tself.CollectionPublicPath=/public/findCharityCollection\n\t\tself.CollectionStoragePath=/storage/findCharityCollection\n\t}\n}\n\n",
            "contract_type": "contract",
            "contract_category": "nft"
        }
    }
}